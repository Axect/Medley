{"_id":"BJbDaElIG","title":"3. Types","body":{"entityMap":{},"blocks":[{"key":"ag6qs","text":"3. Types","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dje9g","text":"What is Type?","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"97pfk","text":"At the lowest level, a computer is only concerned with bytesm with barely any additional structure.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"culsq","text":"Type system gives abstraction","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":18,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"18l31","text":"Usually type system goes beyond this to prevent us from accidentally mixing up types.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"69jju","text":"Abstraction allow us to forget or ignore low-level details.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fdt1e","text":"Haskell's type system allows us to think at a very abstract level.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4ur1t","text":"Haskell's Type System","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1kdhh","text":"Strong","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":6,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"fjdmf","text":"Static","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":6,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"5j4t4","text":"Inferred","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":8,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"3j3mi","text":"Strong Type","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"borkk","text":"Strong means the type system guarantees that a program can't contain certain kinds of errors.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"507lt","text":"# perl","type":"custom-code-block-perl","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"68v68","text":"\"foo\" + 2","type":"custom-code-block-perl","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"81n5k","text":"# result: 2","type":"custom-code-block-perl","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aviqp","text":"-- Haskell","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3tt21","text":"\"foo\" + 2","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"72dq6","text":"-- <interactive>:1:1: error:","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"42lu5","text":"--     • No instance for (Num [Char]) arising from a use of ‘+’","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"katt","text":"--     • In the expression: \"foo\" + 2","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e41q7","text":"--       In an equation for ‘it’: it = \"foo\" + 2","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c0hjm","text":"Static Type","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"faft3","text":"Static means that the compiler knows the type of every value and expression at compile time, before any code is executed.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"81saq","text":"It can occasionally make it difficult to write some useful kinds of code. (compare with duck typing)","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":88,"length":11,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"1cimj","text":"Haskell's system of typeclasses provides almost all of the benefits of dynamic typing, in a safe and convenient form.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":20,"length":12,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"eohu7","text":"Type Inference","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1ltsj","text":"Haskell compiler can automatically deduce the types of almost all expressions in a program.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4rtru","text":"-- Haskell","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c9vch","text":"main = do","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9hci0","text":"    putStrLn $ \"Hello, World\"","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6r676","text":"-- We can write code without explicit types.","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5c0b8","text":"-- Haskell infer main as main :: IO()","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"81n19","text":"Common Basic Types","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5t69c","text":"Char : Represents a Unicode Character","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"c4m7g","text":"Bool : Represents a value in Boolean logic (True or False)","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":4,"style":"BOLD"},{"offset":44,"length":4,"style":"BOLD"},{"offset":52,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"7rkbc","text":"Int : Used for signed, fixed-width integer values. Int depends on the system's longest \"native\" integer","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":4,"style":"BOLD"},{"offset":51,"length":4,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"bj1nd","text":"Integer : A signed integer of unbounded size. Integers are not used as often as Ints. More expensive but reliable.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":7,"style":"BOLD"},{"offset":46,"length":7,"style":"BOLD"},{"offset":80,"length":3,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"esagv","text":"Double : Used for floating-point numbers. Double value is typically 64 bits. (Float is more narrow but more slower!)","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":7,"style":"BOLD"},{"offset":42,"length":6,"style":"BOLD"},{"offset":78,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"cqjga","text":"Useful Composite Data Types - List and Tuples","type":"header-two","depth":0,"inlineStyleRanges":[{"offset":30,"length":5,"style":"BOLD"},{"offset":39,"length":6,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"85lu6","text":"Lists","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6mu67","text":"ghci> head [1,2,3,4]","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"u22n","text":"1","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5nfgq","text":"ghci> head \"Hello\" -- String = [Char]","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8m5mp","text":"'H'","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dognp","text":"ghci> tail [1,2,3,4]","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"friqs","text":"[2,3,4]","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9bgi8","text":"ghci> tail \"Hello\"","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fsmgg","text":"\"ello\"","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8g97q","text":"ghci> :t [[True],[False,False]]","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4kjad","text":"[[True],[False,False]] :: [[Bool]]","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fnal6","text":"Tuples","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"73dmk","text":"Tuple is a fixed-size collection of values, where each value can have a different type.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aocr6","text":"ghci> :t (1964, \"Labyrinths\")","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5knee","text":"(1964, \"Labyrinths\") :: Num t => (t, [Char])","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3dg3l","text":"Functions over Lists and Tuples","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"a3ibp","text":"ghci> take 2 [1,2,3,4,5]","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7ae7c","text":"[1,2]","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ajki2","text":"ghci> drop 3 [1,2,3,4,5]","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"659t5","text":"[4,5]","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bvpb3","text":"ghci> fst (1,'a')","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6funv","text":"1","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5lilu","text":"ghci> snd (1,'a')","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9gg2j","text":"'a'","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5mig1","text":"Properties of Haskell's Function","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3lp8r","text":"Haskell doesn't have a return keyword, because a function is a single expression, not a sequence of statements.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":23,"length":6,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"9nean","text":"Haskell doesn't usually use parenthesis for input of functions.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"amjch","text":"\"=\" represents \"meaning\" (Not Assign) - the name on the left is defined to be the expression on the right.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":1,"length":1,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"70iit","text":"Imperative vs Haskell","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dtn4r","text":"Imperative PL - Variable is a memory location.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":30,"length":16,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"a3crn","text":"Imperative PL - We can change a variable's name at any time","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bpoq7","text":"Haskell - Once we've bound a variable to an expression, we can always substute ir for that expression, because it will not change.","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6oeoi","text":"# Python","type":"custom-code-block-python","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b8c7p","text":"x = 10","type":"custom-code-block-python","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"36r7n","text":"x = 11","type":"custom-code-block-python","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5221r","text":"print x","type":"custom-code-block-python","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dm393","text":"# result: 11","type":"custom-code-block-python","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6bnj2","text":"-- Haskell (s.hs)","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7cpjs","text":"x = 10","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"e8vob","text":"x = 11","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9f54i","text":"-- s.hs:2:1: error:","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bolad","text":"--     Multiple declarations of ‘x’","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"82aqt","text":"--     Declared at: s.hs:1:1","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f09sb","text":"--                  s.hs:2:1","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"19uig","text":"Conditional Evaluation","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"50pkl","text":"-- file: ch02/myDrop.hs","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"4avco","text":"myDrop n xs = if n <= 0 || null xs","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"eca3a","text":"                 then xs","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"72vfh","text":"                 else myDrop (n-1) (tail xs)","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"192up","text":"Additional Functions","type":"header-three","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"375j9","text":"ghci> last [1,2,3,4,5]","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6ribo","text":"5","type":"custom-code-block-haskell","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"dateCreated":"2018-02-01T07:10:17.309Z","lastUpdated":"2018-02-04T05:22:16.672Z","notebookId":"HkXWZ5KBz"}
